import java.io.File;
import java.io.FileNotFoundException;
import java.lang.IllegalArgumentException;
import java.util.Arrays;
import java.util.Scanner;
import java.lang.StringBuilder;

public class TernarySearchTree {
	
	public int size;
	public Node root;
	public File stopsFile;
	
	void File()
	{
		 try {
				File stoptimesFile = new File("stop_times.txt");
				this.stopsFile = stoptimesFile;
	      }
	  catch(Exception e) {
				System.out.print("file not found: stop_times.txt");
		}
	}
	
 
	
  // code related to the Node object
	private class Node
	{
			 public Node left, mid, right;
			 Character character;
			 public StopInfo value;
			 public boolean containsStop = false;
		
		public Node(String key, StopInfo value) 
		{
			if (key.isEmpty() || value == null)
			{
				throw new IllegalArgumentException();
			}
			this.character = key.charAt(0);
			
			if (key.length() > 1) 
			{
				this.mid = new Node(key.substring(1), value);
			} 
			else {
					this.value = value;
					this.containsStop = true;
				}
		}
		
		private Node add(String key, StopInfo value)
		{
				if (root == null)
				{
					root = new Node(key, value);
					return root;
				}
      
				Character c = key.charAt(0);
				if ((this.character).equals(c) == true)
				{
					if (key.length() == 1) 
					{
						this.value = value;
						this.containsStop = true;
					}
					else if (this.mid != null)
					{
						return mid.add(key.substring(1),   );
					}
					else 
					{
						this.mid = new Node(key.substring(1),   );
						return mid.search(key.substring(1));
					}
				}
		
			else if (c.compareTo(character) < 0)
			{
				if (this.left != null) 
				{
					return left.add(key, value);
				}
				else 
					{
						left = new Node(key, value);
						return left.search(key);
					}
			} 
			else 
			{
				if (this.right != null)
				{
					return right.add(key, value);
				} else
				{
					right = new Node(key, value);
					return right.search(key);
				}
			}
		}
		
    public Node search(String key) {
      if (key.isEmpty()) return null;
      Character c = key.charAt(0);
      if (c.equals(this.character)) {
        if (key.length() == 1) return this;
        else if (this.mid == null) return null;
        else return this.mid.search(key.substring(1));
      } else if (c.compareTo(this.character) < 0) {
        if (left == null) return null;
        else return left.search(key);
      } else {
        if (right == null) return null;
        else return right.search(key);
      }
   }

    //Use this one for finding stops with just the start
    //of words
    public String searchStops(String key) {
      StringBuilder builder = new StringBuilder();
      Node searchKeyRoot = searchToEndOfKey(root, key, 0);
      returnListOfStops(searchKeyRoot, "", builder, key);
      if (builder.length() < 1) return "No Matches Found :/";
      return builder.toString();
    }

    private Node searchToEndOfKey(Node node, String key, int ptr) {
      Character c = key.charAt(0);
      if (node == null) return null;
      if (c.equals(this.character)) return searchToEndOfKey(node.left, key, ptr);
      else if (c.compareTo(this.character) < 0) return searchToEndOfKey(node.right, key, ptr);
      else {
        if (ptr == key.length() - 1) return node;
        else return searchToEndOfKey(node.mid, key, ptr + 1);
      }
    }

    private String returnListOfStops(Node node, String string, StringBuilder sb, String key) {
      if (node != null) {
        returnListOfStops(node.left, string, sb, key);
        string = string + node.outputInfo;
        if (node.containsKey) sb.append(word + string.substring(1) + "\n");
        returnListOfStops(node.mid, string, sb, key);
        string = string.substring(0, string.length() - 1);
        returnListOfStops(node.right, string, sb, key);
      }
    }
    
  // read stopsFile into system, creating first a String
  // object, then a StopInfo object, for each line,
  // adding them to an array
    
  public StopInfo[] readStopsInfoFileIntoArray() {
    String stopsAsLines[];
    StopInfo stops[];
    String stopName;
    String stopFirstWord;

    Scanner readStops = new Scanner(stopsFile);
    readStops.nextLine();
    int count = 0;
    while (readStops.hasNextLine()) {
      stopsAsLines[count] = readStops.nextLine();
      count++;
    }
    String splitLine[];
    String splitStopName[];
    for (int i = 0; i < stopsAsLines.length; i++) {
      splitLine = stopsAsLines[i].split("," -1);
      //this next bit checks if the first word of the stop name is one of a few, and moves it to the end if need be
      stopName = splitLine[1];
      stopFirstWord = splitStopName[0];
      splitStopName = stopName.split(" ", -1);
      if (String.equals(stopFirstWord[0], "FLAGSTOP") || String.equals(stopFirstWord[0], "WB") || String.equals(stopFirstWord[0], "NB") || String.equals(stopFirstWord[0], "SB") || String.equals(stopFirstWord[0], "EB")) {
        int wordIndex = stopName.indexOf(" ") + 1;
        String newName = stopName.substring(wordIndex);
        splitLine[1] = newName + " " + stopFirstWord;
      }
      //assign values to StopInfo object
      stops[i].setInfo(splitLine[0], splitLine[1], splitLine[2], splitLine[3], splitLine[4], splitLine[5], splitLine[6], splitLine[7], splitLine[8]);
    }
    readStops.close();
  }
 }
}



